<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=0.7, user-scalable=no" />
  <title>Resizable Canvas — Image Layout Editor</title>
  <style>
    :root{--bg:#f6f7f9;--panel:#ffffff;--accent:#3478f6}
    html,body{min-height:100%;margin:0;font-family:Inter,system-ui,Arial;color:#111;background:var(--bg)}
    .app{display:flex;gap:12px;padding:12px;height:100%;box-sizing:border-box}

    /* left toolbar */
    .panel{width:280px;background:var(--panel);border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(16,24,40,0.06);display:flex;flex-direction:column;gap:10px}
    .panel h2{margin:0;font-size:16px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button,input[type=file],.btn{padding:8px 10px;border-radius:8px;border:1px solid #e6e9ef;background:white;cursor:pointer}
    .btn.primary{background:var(--accent);color:white;border:none}

    /* canvas stage */
    .stage-wrap{flex:1;display:flex;flex-direction:column;gap:8px}
    .stage-toolbar{display:flex;justify-content:space-between;align-items:center}
    .stage{flex:1;background:repeating-linear-gradient(45deg,#fff 0 1px,transparent 1px 20px),linear-gradient(#f8fafc,#fff);border-radius:10px;overflow:auto;padding:12px;resize:none;min-height:200px;min-width:300px;border:1px dashed #e2e8f0;position:relative}

    /* editable canvas area (inner) */
    #canvas{position:relative;width:3600px;height:2400px;background:linear-gradient(180deg,#fff 0,#fbfdff 100%);box-shadow:inset 0 0 0 1px rgba(0,0,0,0.02);}

    /* items */
    .item{position:absolute;touch-action:none;user-select:none;display:flex;align-items:center;justify-content:center}
    .item img{display:block;max-width:100%;max-height:100%;pointer-events:none}

    /* broken image styling */
    .item.broken{outline:2px dashed #ff4d4f;}
    .item.broken::after{content:'broken';position:absolute;left:6px;top:6px;background:#ffefef;color:#a61b1b;padding:2px 6px;border-radius:6px;font-size:11px}

    /* selection border + handles */
    .selected{outline:2px solid var(--accent);outline-offset:3px}
    .handle{position:absolute;width:12px;height:12px;background:white;border:1px solid #334155;border-radius:2px;box-sizing:border-box}
    .handle.nw{left:-8px;top:-8px;cursor:nwse-resize}
    .handle.ne{right:-8px;top:-8px;cursor:nesw-resize}
    .handle.sw{left:-8px;bottom:-8px;cursor:nesw-resize}
    .handle.se{right:-8px;bottom:-8px;cursor:nwse-resize}
    .handle.move{left:50%;top:-28px;transform:translateX(-50%);width:auto;padding:3px 6px;border-radius:6px;cursor:move;background:rgba(255,255,255,0.95);border:1px solid #e6e9ef}

    .small{font-size:13px}
    .muted{color:#6b7280}
    .sidebar-row{display:flex;gap:8px;align-items:center}
    label{font-size:13px}
    .range{width:100%}
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h2>Tools</h2>
      <div class="controls">
        <input id="file" type="file" accept="image/*" />
        <button id="addUrl" class="btn">Add from URL</button>
        <button id="fitAll" class="btn">Fit all</button>
        <button id="clear" class="btn">Clear</button>
      </div>

      <div>
        <div class="sidebar-row"><label class="small">Selected:</label><div id="selInfo" class="muted small">none</div></div>
      </div>

      <div>
        <label class="small">Opacity</label>
        <input id="opacity" type="range" min="0" max="100" value="100" class="range" />
      </div>

      <div style="margin-top:auto">
        <div class="muted small">Keyboard:</div>
        <ul class="muted small">
          <li>Delete — remove selected</li>
          <li>Arrow keys — nudge selected (hold Shift for 10px)</li>
          <li>Ctrl/Cmd + A — select all</li>
        </ul>
      </div>
    </div>

    <div class="stage-wrap">
      <div class="stage-toolbar">
        <div><strong>Canvas</strong> <span class="muted">(resize the panel using the bottom-right handle)</span></div>
        <div class="controls">
          <button id="export" class="btn primary">Export JPEG</button>
        </div>
      </div>

      <div id="stage" class="stage">
        <div id="canvas"></div>
      </div>
    </div>
  </div>

  <script>
    // Simple image-layout editor. Images are DOM elements positioned inside #canvas.
    // Fix included: ensure images are fully loaded and valid (naturalWidth>0) before drawing.
    // If an image is broken it is marked visually and skipped during export (a red X placeholder
    // is drawn instead). This prevents the InvalidStateError: drawImage passed a broken image.

    const canvas = document.getElementById('canvas');
    const fileIn = document.getElementById('file');
    const addUrlBtn = document.getElementById('addUrl');
    const opacityRange = document.getElementById('opacity');
    const selInfo = document.getElementById('selInfo');
    const exportBtn = document.getElementById('export');
    const fitAllBtn = document.getElementById('fitAll');
    const clearBtn = document.getElementById('clear');

    let items = []; // {el, img}
    let selected = null;

    function createItem(imgSrc, opts = {}){
      const wrapper = document.createElement('div');
      wrapper.className = 'item';
      wrapper.style.left = (opts.x || 50) + 'px';
      wrapper.style.top = (opts.y || 50) + 'px';
      wrapper.style.width = (opts.w || 240) + 'px';
      wrapper.style.height = (opts.h || 160) + 'px';
      wrapper.style.touchAction = 'none';

      const img = document.createElement('img');
      // set a data attribute to indicate loading state
      img.dataset.loadstate = 'pending';

      // load handlers
      img.addEventListener('load', ()=>{
        img.dataset.loadstate = 'loaded';
        // scale down if bigger than default
        const naturalW = img.naturalWidth, naturalH = img.naturalHeight;
        if(!opts.w && !opts.h && naturalW && naturalH){
          const maxW = 800; const maxH = 600;
          let w = naturalW, h = naturalH;
          const scale = Math.min(1, maxW/w, maxH/h);
          wrapper.style.width = Math.round(w*scale)+'px';
          wrapper.style.height = Math.round(h*scale)+'px';
        }
      });
      img.addEventListener('error', ()=>{
        img.dataset.loadstate = 'error';
        wrapper.classList.add('broken');
      });

      // assign src after handlers
      img.src = imgSrc;

      wrapper.appendChild(img);

      // selection handles
      const handles = ['nw','ne','sw','se'];
      handles.forEach(h=>{
        const node = document.createElement('div');
        node.className = 'handle '+h;
        wrapper.appendChild(node);
      });
      const moveHandle = document.createElement('div');
      moveHandle.className = 'handle move';
      moveHandle.textContent = 'drag';
      wrapper.appendChild(moveHandle);

      canvas.appendChild(wrapper);

      const obj = {el:wrapper,img,img};
      items.push(obj);

      makeInteractable(obj);
      selectItem(obj);

      return obj;
    }

    // Interactions: drag move, corner resize
    function makeInteractable(obj){
      const el = obj.el;

      el.addEventListener('pointerdown', e=>{
        // ensure pointer captured so subsequent pointer events are routed
        try{ el.setPointerCapture(e.pointerId); }catch(e){}
      });

      // Move
      let moveState = null;
      el.querySelector('.handle.move').addEventListener('pointerdown', e=>{
        e.stopPropagation();
        e.preventDefault();
        selectItem(obj);
        const rect = el.getBoundingClientRect();
        const startX = e.clientX, startY = e.clientY;
        const offsetX = startX - rect.left, offsetY = startY - rect.top;
        moveState = {startX,startY,offsetX,offsetY};

        function onMove(ev){
          const stageRect = canvas.getBoundingClientRect();
          let nx = ev.clientX - stageRect.left - moveState.offsetX + canvas.scrollLeft;
          let ny = ev.clientY - stageRect.top - moveState.offsetY + canvas.scrollTop;
          el.style.left = Math.round(Math.max(0,nx)) + 'px';
          el.style.top = Math.round(Math.max(0,ny)) + 'px';
          updateInfo();
        }
        function onUp(){
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
          moveState = null;
        }
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
      });

      // Dragging whole element by clicking body (also allows dragging by image)
      el.addEventListener('pointerdown', e=>{
        if(e.target.classList.contains('handle') || e.target.classList.contains('move')) return;
        selectItem(obj);
        e.preventDefault();
        const rect = el.getBoundingClientRect();
        const stageRect = canvas.getBoundingClientRect();
        const startX = e.clientX, startY = e.clientY;
        const offsetX = startX - rect.left, offsetY = startY - rect.top;

        function onMove(ev){
          let nx = ev.clientX - stageRect.left - offsetX + canvas.scrollLeft;
          let ny = ev.clientY - stageRect.top - offsetY + canvas.scrollTop;
          el.style.left = Math.round(Math.max(0,nx)) + 'px';
          el.style.top = Math.round(Math.max(0,ny)) + 'px';
          updateInfo();
        }
        function onUp(){
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
        }
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
      });

      // Resize via corners
      ['nw','ne','sw','se'].forEach(dir=>{
        const node = el.querySelector('.handle.'+dir);
        node.addEventListener('pointerdown', ev=>{
          ev.stopPropagation(); ev.preventDefault();
          selectItem(obj);
          const start = {x:ev.clientX,y:ev.clientY};
          const rect = el.getBoundingClientRect();
          const stageRect = canvas.getBoundingClientRect();
          const startW = rect.width, startH = rect.height;
          const startL = rect.left - stageRect.left + canvas.scrollLeft;
          const startT = rect.top - stageRect.top + canvas.scrollTop;

          function onMove(e2){
            let dx = e2.clientX - start.x;
            let dy = e2.clientY - start.y;
            let newW = startW, newH = startH, newL = startL, newT = startT;
            if(dir.includes('e')) newW = Math.max(20, startW + dx);
            if(dir.includes('w')) { newW = Math.max(20, startW - dx); newL = startL + dx; }
            if(dir.includes('s')) newH = Math.max(20, startH + dy);
            if(dir.includes('n')) { newH = Math.max(20, startH - dy); newT = startT + dy; }
            el.style.width = Math.round(newW)+'px';
            el.style.height = Math.round(newH)+'px';
            el.style.left = Math.round(newL)+'px';
            el.style.top = Math.round(newT)+'px';
            updateInfo();
          }
          function onUp(){ window.removeEventListener('pointermove', onMove); window.removeEventListener('pointerup', onUp); }
          window.addEventListener('pointermove', onMove);
          window.addEventListener('pointerup', onUp);
        });
      });

      // selection on click
      el.addEventListener('click', e=>{ e.stopPropagation(); selectItem(obj); });

      // double click to open image in new tab
      el.addEventListener('dblclick', e=>{ window.open(obj.img.src,'_blank'); });

      // opacity binding
      opacityRange.addEventListener('input', ()=>{
        if(selected && selected.el === el){ el.style.opacity = (opacityRange.value/100); }
      });
    }

    function selectItem(obj){
      if(selected && selected.el) selected.el.classList.remove('selected');
      selected = obj;
      if(selected && selected.el){
        selected.el.classList.add('selected');
        // update opacity control
        const currentOpacity = parseFloat(selected.el.style.opacity || 1) * 100;
        opacityRange.value = Math.round(currentOpacity);
        updateInfo();
      } else { selInfo.textContent = 'none'; }
    }

    // update selected info
    function updateInfo(){
      if(!selected){ selInfo.textContent = 'none'; return; }
      const r = selected.el.getBoundingClientRect();
      // position relative to canvas
      const left = parseInt(selected.el.style.left||0);
      const top = parseInt(selected.el.style.top||0);
      const w = Math.round(selected.el.offsetWidth);
      const h = Math.round(selected.el.offsetHeight);
      selInfo.textContent = `x:${left}px y:${top}px — ${w}×${h}px`;
    }

    // add via file
    fileIn.addEventListener('change', e=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      const reader = new FileReader();
      reader.onload = ()=> createItem(reader.result);
      reader.readAsDataURL(f);
      fileIn.value = '';
    });

    // add via URL prompt
    addUrlBtn.addEventListener('click', ()=>{
      const url = prompt('Image URL');
      if(url) createItem(url, {x:60,y:60});
    });

    // global click clears selection
    document.addEventListener('click', ()=>{ if(selected){ selected.el.classList.remove('selected'); selected=null; selInfo.textContent='none'; } });

    // keyboard interactions
    window.addEventListener('keydown', e=>{
      if(!selected) return;
      const step = e.shiftKey?10:1;
      if(e.key === 'Delete' || e.key === 'Backspace'){
        // remove
        canvas.removeChild(selected.el);
        items = items.filter(it=>it!==selected);
        selected = null; selInfo.textContent='none';
      }
      if(e.key.startsWith('Arrow')){
        e.preventDefault();
        const left = parseInt(selected.el.style.left||0);
        const top = parseInt(selected.el.style.top||0);
        if(e.key === 'ArrowLeft') selected.el.style.left = (left - step) + 'px';
        if(e.key === 'ArrowRight') selected.el.style.left = (left + step) + 'px';
        if(e.key === 'ArrowUp') selected.el.style.top = (top - step) + 'px';
        if(e.key === 'ArrowDown') selected.el.style.top = (top + step) + 'px';
        updateInfo();
      }
      if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'a'){
        e.preventDefault();
        // select all — we will just select first for simple behaviour
        if(items.length) selectItem(items[0]);
      }
    });

    // ensureImageLoaded now returns true when image successfully loaded and has non-zero natural size,
    // false when the image failed to load or is corrupted. It listens for both load and error events.
    function ensureImageLoaded(img){
      return new Promise(res=>{
        if(img.complete){
          // complete can be true for both loaded and error states; check naturalWidth
          return res(!!img.naturalWidth);
        }
        function onLoad(){ cleanup(); res(true); }
        function onError(){ cleanup(); res(false); }
        function cleanup(){ img.removeEventListener('load', onLoad); img.removeEventListener('error', onError); }
        img.addEventListener('load', onLoad);
        img.addEventListener('error', onError);
      });
    }

    // export canvas to JPEG using HTML2Canvas-like approach (draw images to an offscreen canvas)
    exportBtn.addEventListener('click', async ()=>{
      const w = canvas.offsetWidth, h = canvas.offsetHeight;
      const out = document.createElement('canvas'); out.width = w; out.height = h;
      const ctx = out.getContext('2d');
      ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,w,h);

      let failedCount = 0;

      // draw each item in DOM order
      for(const it of items){
        const el = it.el;
        const left = parseInt(el.style.left||0);
        const top = parseInt(el.style.top||0);
        const iw = el.offsetWidth, ih = el.offsetHeight;
        // ensure image is loaded and valid
        const ok = await ensureImageLoaded(it.img);
        ctx.globalAlpha = parseFloat(getComputedStyle(el).opacity || 1);
        if(!ok){
          // mark broken visually and draw a placeholder (red X box) instead of calling drawImage
          failedCount++;
          ctx.save();
          ctx.strokeStyle = '#ff4d4f'; ctx.lineWidth = 3;
          ctx.strokeRect(left+2, top+2, Math.max(4, iw-4), Math.max(4, ih-4));
          ctx.beginPath();
          ctx.moveTo(left+6, top+6); ctx.lineTo(left+iw-6, top+ih-6);
          ctx.moveTo(left+iw-6, top+6); ctx.lineTo(left+6, top+ih-6);
          ctx.stroke();
          ctx.restore();
          continue;
        }
        try{
          ctx.drawImage(it.img, left, top, iw, ih);
        }catch(err){
          // defensive: if drawImage still throws, draw placeholder and mark item broken
          console.error('drawImage failed for', it.img.src, err);
          failedCount++;
          ctx.save();
          ctx.strokeStyle = '#ff4d4f'; ctx.lineWidth = 3;
          ctx.strokeRect(left+2, top+2, Math.max(4, iw-4), Math.max(4, ih-4));
          ctx.beginPath();
          ctx.moveTo(left+6, top+6); ctx.lineTo(left+iw-6, top+ih-6);
          ctx.moveTo(left+iw-6, top+6); ctx.lineTo(left+6, top+ih-6);
          ctx.stroke();
          ctx.restore();
          // mark DOM element as broken so user sees it
          it.el.classList.add('broken');
        }
      }
      ctx.globalAlpha = 1;
      const data = out.toDataURL('image/jpeg');
      const a = document.createElement('a'); a.href = data; a.download = 'canvas-export.jpg'; a.click();

      if(failedCount) alert(failedCount + ' image(s) failed to load or were corrupted and were replaced by placeholders in the export.');
    });

    // fit all items inside canvas (simple bounding box)
    fitAllBtn.addEventListener('click', ()=>{
      if(!items.length) return;
      let minX=Infinity,minY=Infinity,maxX=0,maxY=0;
      items.forEach(it=>{
        const l = parseInt(it.el.style.left||0); const t = parseInt(it.el.style.top||0);
        minX = Math.min(minX,l); minY = Math.min(minY,t);
        maxX = Math.max(maxX, l + it.el.offsetWidth); maxY = Math.max(maxY, t + it.el.offsetHeight);
      });
      const pad = 20; const neededW = (maxX-minX)+pad*2; const neededH = (maxY-minY)+pad*2;
      canvas.style.width = neededW+'px'; canvas.style.height = neededH+'px';
      // shift items so they have pad
      items.forEach(it=>{
        const l = parseInt(it.el.style.left||0); const t = parseInt(it.el.style.top||0);
        it.el.style.left = (l - minX + pad)+'px'; it.el.style.top = (t - minY + pad)+'px';
      });
    });

    clearBtn.addEventListener('click', ()=>{ items.forEach(it=>canvas.removeChild(it.el)); items=[]; selected=null; selInfo.textContent='none'; });

  </script>
</body>
</html>
